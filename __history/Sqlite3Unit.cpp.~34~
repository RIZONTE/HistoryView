//---------------------------------------------------------------------------
#include "sqlite3.h"
#pragma hdrstop

#include "Sqlite3Unit.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)

std::string DateConvert(int64_t timestamp)
{  //‘ункци€ преобразует временную метку из 64-бит в строку
	std::string result;
	//timestamp - это количество микросекунд начина€ с 01/01/1601 00:00:00
	//ћагическое число 11644473600 - это  разница в секундах между
	//01/01/1601 00:00:00 и 01/01/1970 00:00:00
	int64_t unixFormat = (timestamp/1000000) - 11644473600;

	time_t datetime = (time_t)unixFormat;

	result = ctime(&datetime);

    return result;
}

bool SQLiteHistory::OpenDatabase(const wchar_t* fileName)
{
	int openResult = sqlite3_open16(fileName, &Database);
	if(openResult != SQLITE_OK)//если не смогли открыть базу данных
	{
		sqlite3_close(Database);
		DatabaseOpened = false;
		return false;
	}

	// ѕровер€ем, €вл€етс€ ли открытый файл базой данных истории браузера
	const char* query = "SELECT count(*) FROM urls";
	char* errorMessage;
	int result = sqlite3_exec(Database, query, NULL, NULL, &errorMessage);
	if(result != SQLITE_OK)
	{
		sqlite3_close(Database);
		sqlite3_free(errorMessage);
		DatabaseOpened = false;
		return false;
	}
    DatabaseOpened = true;
	return true;
}

bool SQLiteHistory::PrepareStatement()
{
	if(DatabaseOpened
    int execResult = sqlite3_prepare16_v2(Database,
                                         L"SELECT id, url, title, last_visit_time FROM urls",
										 -1,
										 &pStatement, NULL);
	if(execResult != SQLITE_OK)
    {
		return false;
	}
	else return true;
}

bool SQLiteHistory::Step()
{
	int stepResult = SQLITE_DONE;

    stepResult = sqlite3_step(pStatement);
	if(stepResult != SQLITE_ROW)
	{
		return false;
	}
    else return true;
}

uint64_t SQLiteHistory::GetId()
{
	return sqlite3_column_int64(pStatement, 0);
}

wchar_t* SQLiteHistory::GetUrl()
{
	return (wchar_t*)sqlite3_column_text16(pStatement, 1);
}
wchar_t* SQLiteHistory::GetTitle()
{
	return (wchar_t*)sqlite3_column_text16(pStatement, 2);
}
int64_t SQLiteHistory::GetLastVisit()
{
	return sqlite3_column_int64(pStatement, 3);
}



